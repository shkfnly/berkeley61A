<html>
<head>
<link href="css/assignments.css" rel="stylesheet" type="text/css">
<title>Trends</title>
</head>

<body>
<h2> Project 2: Twitter Trends </h2>

<blockquote style="text-align:center;">
  <div class="c1"><img src="texas.png"></div>

  <p>What do people tweet?<br>
    Draw their feelings on a map <br>
    to discover <i>trends</i>.</p>
</blockquote>

<h3>Introduction</h3>

<p>In this project, you will develop a geographic visualization of Twitter data
across the USA. You will need to use dictionaries, lists, and data abstraction
techniques to create a modular program. This project uses ideas from Sections
<a href="http://composingprograms.com/pages/21-introduction.html">2.1</a>,
<a href="http://composingprograms.com/pages/22-data-abstraction.html">2.2</a>,
<a href="http://composingprograms.com/pages/23-sequences.html">2.3</a>, and
<a href="http://composingprograms.com/pages/24-mutable-data.html">2.4</a>,
of the <a href="http://composingprograms.com">Composing Programs</a> online
textbook.</p>

<p>The map displayed above depicts how the people in different states feel
about Texas.  This image is generated by:

<ol>
  <li> Collecting public Twitter posts (tweets) that have been tagged with
  geographic locations and filtering for those that contain the "texas" query
  term,
  <li> Assigning a sentiment (positive or negative) to each tweet, based on all
  of the words it contains,
  <li> Aggregating tweets by the state with the closest geographic center, and
  finally
  <li> Coloring each state according to the aggregate sentiment of its tweets.
  Red means positive sentiment; blue means negative.
</ol>

<p>The details of how to conduct each of these steps is contained within the
project description.  By the end of this project, you will be able to map the
sentiment of any word or phrase. The <a href="trends.zip">trends.zip</a> archive
contains all the starter code and all data (<b>81 MB</b>).
</ul>

<p>The project uses several files, but all of your changes will be made to the
first one.</p>

<table cellpadding="10" cellspacing="2">
  <tr>
    <td>
      <p><code><a href="trends.py.html">trends.py</a></code></p>
    </td>

    <td>
      <p>A starter implementation of the main project file.</p>
    </td>
  </tr>

  <tr>
    <td>
      <p><code><a href="geo.py.html">geo.py</a></code></p>
    </td>

    <td>
      <p>Geographic positions, 2-D projection equations, and geographic
      distance functions.</p>
    </td>
  </tr>

  <tr>
    <td>
      <p><code><a href="maps.py.html">maps.py</a></code></p>
    </td>

    <td>
      <p>Functions for drawing maps.</p>
    </td>
  </tr>


  <tr>
    <td>
      <p><code><a href="data.py.html">data.py</a></code></p>
    </td>

    <td>
      <p>Functions for loading Twitter data from files.</p>
    </td>
  </tr>

  <tr>
    <td>
      <p><code><a href="graphics.py.html">graphics.py</a></code></p>
    </td>

    <td>
      <p>A simple Python graphics library.</p>
    </td>
  </tr>

  <tr>
    <td>
      <p><code><a href="ucb.py.html">ucb.py</a></code></p>
    </td>

    <td>
      <p>Utility functions for 61A.</p>
    </td>
  </tr>

  <tr>
    <td>
      <p><code><a href="trends_grader.py.html">trends_grader.py</a></code></p>
    </td>

    <td>
      <p>Test code you can run yourself.</p>
    </td>
  </tr>

  <tr><td><p><code><a href="autograder.py.html">autograder.py</a></code></p></td>
  <td><p>Utility functions for grading.</p></td></tr>

</table>

<p>The <a href="data">data</a> directory contains all the data files needed for
the project, and it's necessary to run the project.   The <a
href="trends.zip">trends.zip</a> archive contains this directory: download it to
get started. Downloading each file individually is error-prone. </p>

<h3>Logistics</h3>

<p>This is a one-week project. You'll work in a team of two people, and you can
complete all problems together with your partner.</p>

<p>Start early! Feel free to ask for help early and often. The course staff is
here to assist you, but we can't help everyone an hour before the deadline. <a
  href="http://www.piazza.com">Piazza</a> awaits. You are not alone! </p>

<p>In the end, you and your partner will submit one project. There are 15
possible points (12 for correctness and 3 for composition). You only need to
submit the file <code><a href="trends.py.html">trends.py</a></code>. You do not need to modify any other
files for this project. To submit the project, change to the directory where the
<code><a href="trends.py.html">trends.py</a></code> file is located and run <code>submit proj2</code>. </p>

<h3>The Autograder</h3>

<p>We've included an autograder which includes tests for each question.  You can
invoke it for a particular question number as follows:</p>

<pre>python3 trends_grader.py -q <i><b>&lt;question number&gt;</b></i></pre>

<p>You can also invoke the autograder for all problems at once using:</p>

<pre>python3 trends_grader.py</pre>

<h3>Debugging Tips</h3>

<ul>
  <li>You can use the functions <code>trace</code>, <code>interact</code>, and
    <code>log_current_line</code> defined in <code><a href="ucb.py.html">ucb.py</a></code> to inspect
    a running program.

  <li>You can load your entire implementation and then interact with the
    current environment using the command:

  <pre>
  python3 -i trends.py
  </pre>

  <li>Add <code>print</code> calls to your functions, but remove them before
    submitting your final version.

  <li>Come to office hours or post on Piazza when you're stuck, before you get
    too frustrated.

</ul>

<h3>Phase 1: The Feelings in Tweets</h3>

<p>In this phase, you will create an abstract data type for tweets, split the
text of a tweet into words, and calculate the amount of positive or negative
feeling in a tweet.</p>

<h4>Tweets</h4>

<p>First, we will define an abstract data type for tweets. To ensure that
we do not violate abstraction barriers later in the project, we will create
two different representations:

<p>(A) The constructor <code>make_tweet</code> returns a Python dictionary with
the following entries:</p>

<pre>
  'text':      a string, the text of the tweet, all in lowercase
  'time':      a datetime object, when the tweet was posted
  'latitude':  a floating-point number, the latitude of the tweet's location
  'longitude': a floating-point number, the longitude of the tweet's location
</pre>

<p>(B) The alternate constructor <code>make_tweet_fn</code> returns a function
that takes a string argument that is one of the keys above and returns the
corresponding value.

<p><b>Problem 1</b> (1 pt). Implement the missing selector and constructor
functions for these two representations: <code>tweet_text</code>,
<code>tweet_time</code>, <code>tweet_location</code> correspond to
representation (A); <code>make_tweet_fn</code> corresponds to
representation(B).

For <code>tweet_location</code> you should return a
<code>position</code> object. The constructors and selectors for this
abstract data type can be found in <tt>geo.py</tt>. Remember to
preserve data abstraction!

<p>The two representations created by <code>make_tweet</code> and
<code>make_tweet_fn</code> do not need to work together, but each constructor
should work with its corresponding selectors. The doctests for
<code>make_tweet</code> and <code>make_tweet_fn</code> ensure that this is the
case. They can be run along with other tests using:

<pre>
python3 trends_grader.py -q 1
</pre>

<p>Next, we will retrieve the words from a tweet and compute their sentiment.

<p><b>Problem 2</b> (2 pt). Improve the <code>extract_words</code>
function as follows:  Assume that a word is any consecutive substring of
<code>text</code> that consists only of ASCII letters.  The string
<code>ascii_letters</code> in the <code>string</code> module contains all
letters in the ASCII character set. The <code>extract_words</code> function
should list all such words in order and nothing else.

<p>When you complete this problem, tests for question 2 should pass:

<pre>
python3 trends_grader.py -q 2
</pre>

<p><b>Problem 3</b> (1 pt). Implement the <code>sentiment</code> abstract data
type, which represents a sentiment value that may or may not exist. The
constructor <code>make_sentiment</code> takes either a numeric value within the
interval -1 to 1, or <code>None</code> to indicate that the value does not
exist. Implement the selectors <code>has_sentiment</code> and
<code>sentiment_value</code> as well.  <i>You may use any representation you
choose, but the rest of your program should not depend on this
representation.</i>

<p>When you complete this problem, the question 3 tests should pass:

<pre>
python3 trends_grader.py -q 3
</pre>

You can also call the <code>print_sentiment</code> function to print the
sentiment values of all sentiment-carrying words in a line of text.

<pre>
python3 trends.py -p computer science is my favorite!
python3 trends.py -p life without lambda: awful or awesome?
</pre>

<p><b>Problem 4</b> (1 pt). Implement <code>analyze_tweet_sentiment</code>,
which takes a tweet (of the abstract data type) and returns a
<code>sentiment</code>.  Read the docstrings for <code>get_word_sentiment</code>
and <code>analyze_tweet_sentiment</code> in <code><a href="trends.py.html">trends.py</a></code> to understand
how the two functions interact. <i>Your implementation should not depend on the
representation of a sentiment!</i>.

<p>The <code>tweet_words</code> function should prove useful here: it
combines the <code>tweet_text</code> selector and
<code>extract_words</code> function from the previous questions to
return a list of words in a tweet.</p>

<p>When you complete this problem, the question 4 tests should pass:

<pre>
python3 trends_grader.py -q 4
</pre>

<h3>Phase 2: The Geometry of Maps</h3>

<p>In this phase, we will implement two functions that together determine the
centers of U.S. states. The shape of a state is represented as a list of
polygons.  Some states (e.g. Hawaii) consist of multiple polygons, but most
states (e.g. Colorado) consist of only one polygon (still represented as a
length-one list).</p>

<p>We will use the position abstract data type to represent geographic
latitude-longitude positions on the Earth. The data abstraction, defined at the
top of <code><a href="geo.py.html">geo.py</a></code>, has the constructor <code>make_position</code> and
the selectors <code>latitude</code> and <code>longitude</code>.

<p><b>Problem 5</b> (2 pt). Implement <code>find_centroid</code>, which takes a
polygon and returns three values: the coordinates of its centroid and its area.
The input polygon is represented as a list of <code>position</code> values that
are consecutive vertices of its perimeter.  The first vertex is always identical
to the last.

<p>The centroid of a two-dimensional shape is its center of balance, defined as
the intersection of all straight lines that evenly divide the shape into
equal-area halves.  <code>find_centroid</code> returns the centroid and area of
an individual polygon.

<p>The formula for computing the <a
  href="http://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon">centroid of a
  polygon</a> appears on Wikipedia. The formula relies on vertices being
consecutive (either clockwise or counterclockwise; both give the same answer),
a property that you may assume always holds for the input.

<p><i>Hint</i>: latitudes correspond to the <code>x</code> values, and
longitudes correspond to the <code>y</code>values.</p>

<p>The area of a polygon is never negative.  Depending on how you compute the
area, you may need to use the built-in <code>abs</code> function to return a
non-negative number.</p>

<p>Manipulate positions using their selectors (<code>latitude</code> and
<code>longitude</code>) rather than assuming a particular representation.

<p>When you complete this problem, the question 5 tests should pass:

<pre>
python3 trends_grader.py -q 5
</pre>

<p><b>Problem 6</b> (1 pt). Implement <code>find_state_center</code>, which
takes a state represented by a list of polygons and returns a
position <b>object</b>, its centroid.

<p>The centroid of a collection of polygons can be computed by <a
href="http://en.wikipedia.org/wiki/Centroid#By_geometric_decomposition">
geometric decomposition</a>.  The centroid of a shape is the weighted average of
the centroids of its component polygons, weighted by their area.

<p>When you complete this problem, the question 6 tests should pass:

<pre>
python3 trends_grader.py -q 6
</pre>

<p>Once you are finished, <code>draw_centered_map</code> will draw the
<code>10</code> states closest to a given state (including that state). A red
dot should appear over the two-letter postal code of the specified state.

<pre>
python3 trends.py -d CA
</pre>

<p>Your program should work identically, even if you use the functional
representation for tweets defined in question 1, using the -f flag.

<pre>
python3 trends.py -f -d CA
</pre>


<h3>Phase 3: The Mood of the Nation</h3>

<p>In this phase, you will group tweets by their nearest state center and
calculate the average positive or negative feeling in all the tweets associated
with a state.</p>

<p>The name <code>us_states</code> is bound to a dictionary containing the
shape of each U.S. state, keyed by its two-letter postal code. You can use
the keys of this dictionary to iterate over all the U.S. states.

<p><b>Problem 7</b> (2 pt). Implement <code>group_tweets_by_state</code>, which
takes a sequence of tweets and returns a dictionary.  The keys of the returned
dictionary are state names (two-letter postal codes), and the values are lists
of tweets that appear closer to that state's center than any other.

<p>You should not include any states as keys that are not nearest to any tweet.
You may want to define additional functions to organize your implementation into
modular components. You will need to use the dictionary of
<code>us_states</code> described above.

<p>When you complete this problem, the question 7 tests should pass:

<pre>
python3 trends_grader.py -q 7
</pre>

<p><b>Problem 8</b> (2 pt). Implement <code>average_sentiments</code>.  This
function takes the dictionary returned by <code>group_tweets_by_state</code>
and also returns a dictionary.  The keys of the returned dictionary are the
state names (two-letter postal codes), and the values are average sentiment
values for all the tweets <b>that have sentiment value</b> in that state.

<p>If a state has no tweets with sentiment values, leave it out of the returned
dictionary entirely.  Do not include a state with no sentiment using a zero
sentiment value.  Zero represents neutral sentiment, not unknown sentiment.
States with unknown sentiment will appear gray, while states with neutral
sentiment will appear white.

<p>When you complete this problem, the question 8 tests should pass:

<pre>
python3 trends_grader.py -q 8
</pre>


<p>You should now be able to draw maps that are colored by sentiment
corresponding to tweets that contain a given term. The correct map for Texas
appears at the top of this page.

<pre>
python3 trends.py -m texas
python3 trends.py -m sandwich
python3 trends.py -m obama
python3 trends.py -m my life
</pre>

<p>Your program should work identically, even if you use the functional
representation for tweets defined in question 1, using the -f flag.

<pre>
python3 trends.py -f -m texas
</pre>

<p><i>Congratulations!</i> One more 61A project completed.


<h3>Extensions</h3>

<p>These extensions are optional and ungraded.  In this class, you are welcome
to program just for fun.  If you build something interesting, come to office
hours and give us a demo. However, please do not change the behavior or
signature of the functions you have already implemented.

<ul>

  <li>Implement a function <code>draw_map_by_hour</code> that visualizes the
  tweets that were posted during each hour of the day. For example, you'll discover that "sandwich" tweets appear most positive at 10:00pm: late night snack!

  <li>Punctuation can be an indicator of sentiment as well.  Add an emoticon
  (smiley) detector that attributes positive sentiment to happy faces
  <code>:-)</code> and negative sentiment to sad ones.

  <li>In the standard implementation, some tweets are associated with different
  states than the ones in which they occurred.  For example, all tweets from
  Manhattan are assigned to New Jersey.  New Yorkers would be appalled! Write a
  function <code>find_containing_state</code> that finds the state that
  actually contains a tweet position.

  <li>The <code><a href="graphics.py.html">graphics.py</a></code> package supports animation.  Use the
  <code>slide_shape</code> method to have states and dots slide into place.

  <li><a href="http://norvig.com/spell-correct.html">Correct the spelling</a> of
  tweets before you compute their sentiment.

  <li>Calculate the total average sentiment of the whole country for a term and
  display that using the map.py and graphics.py package (try and understand the
  implementation of draw_most_talkative_states then use it as a foundation and
  modify as needed)
</ul>

<p><b>Acknowledgements:</b> Aditi Muralidharan developed this project with John
DeNero. Hamilton Nguyen extended it. Keegan Mann developed the autograder. Many
others have contributed as well.

</body>
</html>